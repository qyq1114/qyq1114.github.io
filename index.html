<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Yuqi Qin&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yuqi Qin&#39;s Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yuqi Qin&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Yuqi Qin's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuqi Qin's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/前端面试题总结2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/前端面试题总结2019/" itemprop="url">前端面试题总结2019</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-15T23:12:07+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-HTTP-304状态码"><a href="#1-HTTP-304状态码" class="headerlink" title="1.HTTP 304状态码"></a>1.HTTP 304状态码</h2><p>客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。<br>对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。<br>因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。当这些缓存有效的时候，通过 Fiddler 或HttpWatch 查看一个请求会得到这样的结果：</p>
<h2 id="2-缓存的分类"><a href="#2-缓存的分类" class="headerlink" title="2.缓存的分类"></a>2.缓存的分类</h2><p>在Web应用领域，Web缓存大致可以分为以下几种类型：</p>
<ol>
<li><p>数据库数据缓存<br>Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。  </p>
</li>
<li><p>服务器端缓存</p>
<ul>
<li><p>代理服务器缓存<br>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid,Nginx,Apache等。</p>
</li>
<li><p>CDN缓存<br>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p>
</li>
</ul>
</li>
<li><p>浏览器端缓存<br>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</p>
</li>
<li><p>Web应用层缓存<br>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p>
<h2 id="3-前端性能优化"><a href="#3-前端性能优化" class="headerlink" title="3.前端性能优化"></a>3.前端性能优化</h2><p>减少http请求数量：就是资源的合并<br>减少http请求大小：就是资源的压缩</p>
<h2 id="4-HTTPS比HTTP慢的原因"><a href="#4-HTTPS比HTTP慢的原因" class="headerlink" title="4.HTTPS比HTTP慢的原因"></a>4.HTTPS比HTTP慢的原因</h2><p>HTTPs链接比不加密的HTTP链接慢很多。</p>
</li>
</ol>
<p>HTTPs链接和HTTP链接都建立在TCP协议之上。HTTP链接比较单纯，使用三个握手数据包建立连接之后，就可以发送内容数据了。</p>
<p>客户端首先发送SYN数据包，然后服务器发送SYN+ACK数据包，最后客户端发送ACK数据包，接下来就可以发送内容了。这三个数据包的发送过程，叫做TCP握手。</p>
<p>再来看HTTPs链接，它也采用TCP协议发送数据，所以它也需要上面的这三步握手过程。而且，在这三步结束以后，它还有一个SSL握手。</p>
<p>HTTP耗时 = TCP握手</p>
<p>HTTPs耗时 = TCP握手 + SSL握手<br> 所以，HTTPs肯定比HTTP耗时，这就叫SSL延迟。</p>
<p>命令行工具curl有一个w参数，可以用来测量TCP握手和SSL握手的具体耗时，以访问支付宝为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -w &quot;TCP handshake: %&#123;time_connect&#125;， SSL handshake: %&#123;time_appconnect&#125;\n&quot; -so </span><br><span class="line">/dev/null https://www.alipay.comTCP handshake: 0.022, SSL handshake: 0.064</span><br></pre></td></tr></table></figure>

<p> 上面命令中的w参数表示指定输出格式，timeconnect变量表示TCP握手的耗时，timeappconnect变量表示SSL握手的耗时，s参数和o参数用来关闭标准输出。</p>
<p>从运行结果可以看到，SSL握手的耗时（64毫秒）大概是TCP握手（22毫秒）的三倍。</p>
<p>也就是说，在建立连接的阶段，HTTPs链接比HTTP链接要长3倍的时间，具体数字取决于CPU的快慢。</p>
<p>所以，如果是对安全性要求不高的场合，为了提高网页性能，建议不要采用保密强度很高的数字证书。一般场合下，1024位的证书已经足够了，2048位和4096位的证书将进一步延长SSL握手的耗时。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/VUE前端面试题总结2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/VUE前端面试题总结2019/" itemprop="url">VUE前端面试题总结2019</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:38:19+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前端主流MVVM框架双向绑定原理简述："><a href="#1-前端主流MVVM框架双向绑定原理简述：" class="headerlink" title="1. 前端主流MVVM框架双向绑定原理简述："></a>1. 前端主流MVVM框架双向绑定原理简述：</h2><h3 id="AngularJs（脏检测机制）："><a href="#AngularJs（脏检测机制）：" class="headerlink" title="AngularJs（脏检测机制）："></a>AngularJs（脏检测机制）：</h3><p>脏检查机制，主要是依据 $watch 对象来监测数据是否更新。</p>
<h3 id="Vue-js（前端数据对象劫持）："><a href="#Vue-js（前端数据对象劫持）：" class="headerlink" title="Vue.js（前端数据对象劫持）："></a>Vue.js（前端数据对象劫持）：</h3><p>Vue.js是通过数据劫持结合发布者-订阅者模式的方式来实现的。</p>
<h3 id="React（手动触发绑定）："><a href="#React（手动触发绑定）：" class="headerlink" title="React（手动触发绑定）："></a>React（手动触发绑定）：</h3><p>React本身并没有提到双向绑定的概念，但是可以利用setState api对states数据进行更新，从而实现数据层于视图层的同步更新（结构更新，重新“渲染”子树（虚拟DOM），找出最小改动步骤，打包DOM操作，对真实DOM树进行修改）。</p>
<h2 id="2-简述Vue的响应式原理"><a href="#2-简述Vue的响应式原理" class="headerlink" title="2. 简述Vue的响应式原理"></a>2. 简述Vue的响应式原理</h2><p>当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h2 id="3-Vue-给对象新增属性"><a href="#3-Vue-给对象新增属性" class="headerlink" title="3. Vue-给对象新增属性"></a>3. Vue-给对象新增属性</h2><p>官方定义：</p>
<p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</p>
<p>Vue.set(vm.obj, ‘e’, 0)<br>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</p>
<p>this.$set(this.obj,’e’,02)</p>
<p>有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>
<p>// 代替 Object.assign(this.obj, { a: 1, e: 2 })<br>this.obj= Object.assign({}, this.obj, { a: 1, e: 2 })</p>
<h2 id="4-网页从输入网址到渲染完成经历了哪些过程？"><a href="#4-网页从输入网址到渲染完成经历了哪些过程？" class="headerlink" title="4. 网页从输入网址到渲染完成经历了哪些过程？"></a>4. 网页从输入网址到渲染完成经历了哪些过程？</h2><p>大致可以分为如下7步：</p>
<ul>
<li>输入网址</li>
<li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址</li>
<li>与web服务器建立TCP连接</li>
<li>浏览器向web服务器发送http请求</li>
<li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）</li>
<li>浏览器下载web服务器返回的数据及解析html源文件</li>
<li>生成DOM树，解析css和js，渲染页面，直至显示完成</li>
</ul>
<h2 id="5-jQuery获取的dom对象和原生的dom对象有何区别？"><a href="#5-jQuery获取的dom对象和原生的dom对象有何区别？" class="headerlink" title="5.  jQuery获取的dom对象和原生的dom对象有何区别？"></a>5.  jQuery获取的dom对象和原生的dom对象有何区别？</h2><p>js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。</p>
<p>原生DOM对象转jQuery对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var box = document.getElementById(&apos;box&apos;);</span><br><span class="line">var $box = $(box);</span><br></pre></td></tr></table></figure>

<p>jQuery对象转原生DOM对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var $box = $(&apos;#box&apos;);</span><br><span class="line">var box = $box[0];</span><br></pre></td></tr></table></figure>

<h2 id="6-v-model语法糖"><a href="#6-v-model语法糖" class="headerlink" title="6. v-model语法糖"></a>6. v-model语法糖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;something&quot;&gt;</span><br><span class="line">等于</span><br><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>v-model=”something”则表示将value值绑定在something上，当值发生改变时触发绑定的oninput事件。oninput事件绑定的函数是将触发oninput事件的目标（该input）的value值赋值给something这个变量。</p>
<h2 id="7-v-if和v-show指令"><a href="#7-v-if和v-show指令" class="headerlink" title="7. v-if和v-show指令"></a>7. v-if和v-show指令</h2><p>v-if 是条件渲染指令，控制的是组件是否创建(渲染)，值为true则渲染该组件，值为false则不渲染该组件，对应Html元素则不会存在于浏览器的html文档中，即打开浏览器调试工具找不到该组件对应的渲染结果。<br>v-show控制的是组件是否可见，并且是通过css样式的display属性来控制组件的显示与隐藏，所以其值无论是true还是false，对应Html元素都会存在于浏览器的html文档中，即打开浏览器调试工具都能够找到该组件对应的渲染结果，只不过值为false的时候，会在该组件上添加style=”display: none;”；<br>需要注意的是，在vue组件开发的时候，即在.vue中使用v-show的时候，当给<code>&lt;style&gt;</code>标签添加上scoped，会导致其中的css优先级变高，此时如果添加了v-show的元素上同时使用了display样式，那么将会导致v-show为false的时候添加的dispaly:none失效。</p>
<h2 id="8-v-for-与-v-if-的优先级"><a href="#8-v-for-与-v-if-的优先级" class="headerlink" title="8. v-for 与 v-if 的优先级"></a>8. v-for 与 v-if 的优先级</h2><p>v-for比v-if优先级更高，所以不建议v-for和v-if一起使用，如果v-for和v-if同时使用，那么数据发生变化时，v-for首先会进行遍历，然后通过v-if进行判断，这样v-for和v-if都会同时执行一遍，对性能和展现不友好。<br>所以vue建议用计算属性进行替代，返回过滤后的列表再进行遍历。</p>
<h2 id="9-v-for循环中key作用"><a href="#9-v-for循环中key作用" class="headerlink" title="9. v-for循环中key作用"></a>9. v-for循环中key作用</h2><p>key的作用主要就是为了性能优化，key让组件具有了唯一性，能让diff算法更快的找到需要更新的组件dom，在绑定key的时候，最好是一个唯一的值，如 item.id  而不能是简单的index，如果不使用唯一key，那么在有状态组件中会出现渲染错误。因为它默认用就地复用策略，如果数据项的顺序被改变，那么vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，不会重新排列元素的位置。如果是使用 key，它会基于key重新排列元素顺序，并且会移除 key 不存在的元素。<br>简单说就是，<b>不使用key就会原地复用，使用key就会对元素位置进行重新排列，能够关联数据状态。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;&lt;!--注意，这里不能使用:key=&quot;index&quot;--&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot;&gt;&#123;&#123;item.name&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: () =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list: [</span><br><span class="line">              &#123; id: 0, name: &apos;A&apos; &#125;,</span><br><span class="line">              &#123; id: 1, name: &apos;B&apos; &#125;,</span><br><span class="line">              &#123; id: 2, name: &apos;C&apos; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">        add() &#123;</span><br><span class="line">          this.list.unshift(&#123; id:3, name:&apos;D&apos;&#125;) // 将D添加到A的前面</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果v-for上不加key，那么当勾选A前面的复选框后，再点击添加按钮，D会添加到A的前面，由于原地复用原则，不会进行位置的移动，所以第一个位置的复选框是勾选状态会被继承到D上，即D会变成勾选状态而A将失去勾选状态，这个显然与原来状态不符；如果v-for上加上<code>:key=&quot;item.id&quot;</code>，那么D添加到A前面之后，A、B、C都会向后移动，然后再将D插入到A的前面，所以插入D后，A仍然保持勾选状态。</p>
<h2 id="10-vue路由传参数的三种方式"><a href="#10-vue路由传参数的三种方式" class="headerlink" title="10. vue路由传参数的三种方式"></a>10. vue路由传参数的三种方式</h2><p>① query: 直接输入url地址，url地址上带上查询参数，如: <code>localhost:8080/home?foo=1</code> 或者 通过路由对象 <code>$router</code> 调用push()方法进行传参<code>this.$router.push({path:&quot;/home&quot;,query:{&quot;foo&quot;:&quot;1&quot;}})</code>;然后通过<code>this.$route.query.foo</code>进行获取传递过来的参数</p>
<p>② params: 通过路由对象<code>$router</code>调用push()方法进行传参<code>this.$router.push({name:&quot;home&quot;, params:{foo: 1}})</code>;然后通过<code>this.$route.params.foo</code>获取传递过来的参数</p>
<p>③ 动态路由传参: 路由path位置为<code>/home/:foo</code>，然后输入url，如: <code>localhost:8080/home/1</code> 然后通过<code>this.$route.params.foo</code>获取传递过来的参数</p>
<h2 id="11-v-on-常用修饰符"><a href="#11-v-on-常用修饰符" class="headerlink" title="11.v-on 常用修饰符"></a>11.v-on 常用修饰符</h2><p>.stop 该修饰符将阻止事件向上冒泡。同理于调用 event.stopPropagation() 方法，即如果当前元素添加了.stop修饰符，那么当点击该元素时候，click事件不会冒泡到其父元素上，即父元素不会触发click事件。<br>.prevent 该修饰符会阻止当前事件的默认行为。同理于调用 event.preventDefault() 方法，即如果&lt;a href=”<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a> @click.stop=”show”&gt;连接，点击后默认会跳转到百度，但是添加上.stop修饰符之后，就不会跳转到百度了，而是执行show()方法了。<br>.self 该指令只有当事件是从事件绑定的元素本身触发时才触发回调，即冒泡事件到达该元素上时，并不会触发事件，但是其不影响事件继续向上冒泡，其父元素仍然会触发冒泡事件<br>.native 就是给自定义组件的根元素添加一个原生事件，所以其通常用在自定义组件上，如果给普通的HTML元素添加.native修饰符，那么该HTML元素将无法监听到该事件了。<br>.capture 就是让事件监听变成捕获，默认为冒泡，通常用于修饰父元素，如果给父元素添加@click.capture修饰符，那么当点击子元素的时候，父元素的click事件将先触发，然后才是子元素的click事件。<br>.once 该修饰符表示绑定的事件只会被触发一次。</p>
<h2 id="12-vue中的-ref"><a href="#12-vue中的-ref" class="headerlink" title="12.vue中的 ref"></a>12.vue中的 ref</h2><p>ref 被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的 $refs 对象上，即类似于给组件或者DOM元素上添加一个标识id，然后通过这个标识id拿到对应的DOM元素或组件实例，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</p>
<h2 id="13-route和-router的区别"><a href="#13-route和-router的区别" class="headerlink" title="13. $route和$router的区别"></a>13. <code>$route</code>和<code>$router</code>的区别</h2><p>$route是”路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。<br>$router是”路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
<h2 id="14-Vue定义组件"><a href="#14-Vue定义组件" class="headerlink" title="14.Vue定义组件"></a>14.Vue定义组件</h2><p>全局定义：调用Vue的component()方法创建，Vue.component(组件名, {template: 模板字符串})<br>​局部定义：在创建Vue实例时传递的options对象中的components对象中进行定义，components:{组件名: {template: 模板字符串}}<br>单文件组件：在.vue文件中定义，包含template，script，style三部分。</p>
<h2 id="15-Vue-cli的src文件夹中有哪些文件"><a href="#15-Vue-cli的src文件夹中有哪些文件" class="headerlink" title="15.Vue-cli的src文件夹中有哪些文件"></a>15.Vue-cli的src文件夹中有哪些文件</h2><p>assets文件夹是放静态资源；<br>components是放组件；<br>router是定义路由相关的配置;<br>view视图；<br>app.vue是一个应用主组件；<br>main.js是入口文件</p>
<h2 id="16-对于MVVM的理解"><a href="#16-对于MVVM的理解" class="headerlink" title="16.对于MVVM的理解"></a>16.对于MVVM的理解</h2><p>MVVM 是 Model-View-ViewModel 的缩写。<br>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h2 id="17-vue等单页面应用及其优缺点"><a href="#17-vue等单页面应用及其优缺点" class="headerlink" title="17.vue等单页面应用及其优缺点"></a>17.vue等单页面应用及其优缺点</h2><p>优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。<br>缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>
<h2 id="18-计算属性（computed）、方法（methods）和侦听属性（watch）的区别与使用场景"><a href="#18-计算属性（computed）、方法（methods）和侦听属性（watch）的区别与使用场景" class="headerlink" title="18. 计算属性（computed）、方法（methods）和侦听属性（watch）的区别与使用场景"></a>18. 计算属性（computed）、方法（methods）和侦听属性（watch）的区别与使用场景</h2><h3 id="methods-VS-computed"><a href="#methods-VS-computed" class="headerlink" title="*methods VS computed"></a>*methods VS computed</h3><p>我们可以将同一函数定义为一个 method 而不是一个计算属性。对于最终的结果，两种方式确实是相同的。<br>然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。<br>相比而言，只要发生重新渲染，method 调用总会执行该函数。总之，重新计算开销很大的话请选计算属性，不希望有缓存的请选methods。</p>
<h3 id="watch-VS-computed"><a href="#watch-VS-computed" class="headerlink" title="*watch VS computed"></a>*watch VS computed</h3><p>当你在模板内使用了复杂逻辑的表达式时，你应当使用计算属性。<br>侦听属性是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。<br>当你有一些数据需要随着其它数据变动而变动时，或者当需要在数据变化时执行异步或开销较大的操作时，你可以使用 watch。</p>
<h2 id="19-axios是什么？怎么使用？"><a href="#19-axios是什么？怎么使用？" class="headerlink" title="19.axios是什么？怎么使用？"></a>19.axios是什么？怎么使用？</h2><p>axios是基于Promise的，用于浏览器和nodeJS的http客户端，主要作用就是向后台发送请求。其存在许多优点:</p>
<ul>
<li>支持Promise</li>
<li>支持并发请求</li>
<li>提供拦截器</li>
<li>浏览器支持防止csrf(跨站请求伪造)</li>
</ul>
<h2 id="20-axios、fetch、ajax-jquery-的区别"><a href="#20-axios、fetch、ajax-jquery-的区别" class="headerlink" title="20.axios、fetch、ajax(jquery)的区别"></a>20.axios、fetch、ajax(jquery)的区别</h2><p>axios和fetch是基于Promise的，ajax是基于callback的形式。fetch脱离了xhr，是新的语法，默认是不传cookie的，监听不到请求进度。</p>
<h2 id="21-vuex是什么？哪种功能场景使用它"><a href="#21-vuex是什么？哪种功能场景使用它" class="headerlink" title="21.vuex是什么？哪种功能场景使用它"></a>21.vuex是什么？哪种功能场景使用它</h2><p>vuex是一个专门为vue构建的状态机管理机制，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化，主要解决组件间数据共享的问题，其实就是采用类似全局对象的形式来管理所有组件的公共数据，其强调的是集中式管理，主要是为了便于维护、组件解耦，适合大型项目，有多个视图组件共同依赖一个状态的情况下使用，比如商城系统、外卖系统。<br>vuex的核心: state、getters、mutations、actions、modules。</p>
<h2 id="22-vue当中常用的指令及其用法"><a href="#22-vue当中常用的指令及其用法" class="headerlink" title="22.vue当中常用的指令及其用法"></a>22.vue当中常用的指令及其用法</h2><p>v-if: 这是一个条件渲染指令，代表存在和销毁，用于控制组件的创建与否;<br>v-bind: 这是一个绑定指令，用于绑定属性，可简写为冒号;<br>v-on: 这是一个监听指令，用于监听事件，可简写为@;<br>v-for: 这是一个循环指令，用于遍历数组;</p>
<h2 id="23-v-model"><a href="#23-v-model" class="headerlink" title="23.v-model"></a>23.v-model</h2><p>v-model主要用于数据的双向绑定，其内部主要完成了两个操作: 通过v-bind绑定value属性值和监听input事件，并更新数据</p>
<h2 id="24-路由懒加载"><a href="#24-路由懒加载" class="headerlink" title="24.路由懒加载"></a>24.路由懒加载</h2><p>所谓路由懒加载，即在项目打包的时候，项目中通常会有多个路由，如果将所有路由对应的组件都打包到一个文件中，那么最终打包的文件就会变得非常大，会影响页面的加载性能，如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才异步加载出对应组件，这样就会变得更加高效。<br>所以其原理就是利用了webpack的代码分割(按需加载)机制和vue的异步组件功能，代码被分割后就会变成一个单独的文件，所以路由被访问的时候需要向服务器发起请求加载该组件，这是一个异步的过程，所以需要使用到vue的异步组件机制。</p>
<p>异步组件，就是在注册组件的时候，传入一个函数，然后这个函数返回一个Promise对象，resolve的值为这个组件对象，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &apos;/about&apos;,</span><br><span class="line">          name: &apos;about&apos;,</span><br><span class="line">          component: () =&gt; &#123; // 注册为一个异步组件</span><br><span class="line">              const About = require(&quot;./views/About.vue&quot;);</span><br><span class="line">              return Promise.resolve(About);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者在注册异步组件的时候传入resolve和reject，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &apos;/about&apos;,</span><br><span class="line">          name: &apos;about&apos;,</span><br><span class="line">          component: (resolve, reject) =&gt; &#123; // 注册为一个异步组件</span><br><span class="line">              const About = require(&quot;./views/About.vue&quot;);</span><br><span class="line">              resolve(About);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>webpack提供的import()函数会返回一个Promise对象，并且会对引入的组件进行代码分割，所以可以通过import()同时实现代码分割和组件异步加载，即路由懒加载，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &apos;/about&apos;,</span><br><span class="line">          name: &apos;about&apos;,</span><br><span class="line">          component: () =&gt; import(&apos;./views/About.vue&apos;) </span><br><span class="line">          // 等价于注册异步组件并返回一个Promise对象，分割代码的同时进行异步加载</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="25-插槽"><a href="#25-插槽" class="headerlink" title="25.插槽"></a>25.插槽</h2><p>插槽其实就是组件中提供的占位符，所以插槽占位符在组件中使用，插槽有三种: 匿名插槽、具名插槽、作用域插槽。</p>
<ul>
<li><p>匿名插槽：即没有名字的插槽，即<code>&lt;slot&gt;&lt;/slot&gt;</code>，使用组件的时候会将组件中的innerHTML插入到<code>&lt;slot&gt;&lt;/slot&gt;</code>位置上，相当于动态向组件内部传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// About.vue组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 使用About组件</span><br><span class="line">&lt;About&gt;</span><br><span class="line">    &lt;h1&gt;hello world&lt;/h1&gt;&lt;!--该内容会插入到上面&lt;slot&gt;&lt;/slot&gt;位置上，即替换掉&lt;slot&gt;&lt;/slot&gt;--&gt;</span><br><span class="line">&lt;/About&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽: 即有名字的插槽，需要在<code>&lt;slot&gt;</code>标签上添加一个name属性，指定<code>&lt;slot&gt;</code>的名称，即<code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code>，同时使用组件的时候需要给其中的innerHTML添加slot属性，属性值为<code>&lt;slot&gt;</code>的name属性值，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// About.vue组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;!--定义slot的名称为header--&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 使用About组件</span><br><span class="line">&lt;About&gt;</span><br><span class="line">    &lt;h1 slot=&quot;header&quot;&gt;header&lt;/h1&gt; &lt;!--该内容会被插入到名称为header的slot上--&gt;</span><br><span class="line">&lt;/About&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽: 作用域插槽可以理解为组件向外输出数据，我们可以在组件的<code>&lt;slot&gt;</code>标签上添加上一些属性，然后其中的属性值可以传到组件外使用，会将slot标签上的所以属性合并到一个对象对外输出，组件外通过slot-scope指定一个变量名来接收这个对象，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// About.vue组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1 slot=&quot;footer&quot; slot-scope=&quot;innerData&quot;&gt;&#123;&#123;innerData.msg&#125;&#125; &#123;&#123;innerData.foo&#125;&#125;&lt;/h1&gt;&lt;!--指定innerData变量接收组件slot标签中属性集对象--&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 使用About组件</span><br><span class="line">&lt;About&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot; msg=&quot;haha&quot; foo=&quot;foo&quot;&gt;&lt;/slot&gt;&lt;!--会将其中的属性合并成一个对象对外输出--&gt;</span><br><span class="line">&lt;/About&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="26-请详细说下你对vue生命周期的理解"><a href="#26-请详细说下你对vue生命周期的理解" class="headerlink" title="26.请详细说下你对vue生命周期的理解"></a>26.请详细说下你对vue生命周期的理解</h2><p>vue生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。</p>
<ul>
<li>beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化</li>
<li>created (创建后) 完成了 data数据初始化, el还未初始化</li>
<li>beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li>mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互</li>
<li>beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li>updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li>beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。</li>
<li>destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h2 id="27-Vue的双向数据绑定原理"><a href="#27-Vue的双向数据绑定原理" class="headerlink" title="27.Vue的双向数据绑定原理"></a>27.Vue的双向数据绑定原理</h2><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>具体实现步骤，感兴趣的可以看看:</p>
<ul>
<li>当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己；2、自身必须有一个update()方法；3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ul>
<p><a href="https://www.jianshu.com/p/c4dfc5806178" target="_blank" rel="noopener">https://www.jianshu.com/p/c4dfc5806178</a></p>
<h2 id="28-Vue组件复用时，vue-router如何响应路由参数的变化"><a href="#28-Vue组件复用时，vue-router如何响应路由参数的变化" class="headerlink" title="28.Vue组件复用时，vue-router如何响应路由参数的变化"></a>28.Vue组件复用时，vue-router如何响应路由参数的变化</h2><p>当使用路由参数时，例如从 /user/lucy 导航到 /user/lily，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用，复用组件时，想对路由参数的变化作出响应的话，有两种方式:</p>
<ul>
<li><p>监听$route对象数据变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;$route&apos;: (to, from) =&gt;&#123;</span><br><span class="line">      console.log(&quot;route change&quot;);// 对路由变化作出响应...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过beforeRouteUpdate路由钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  beforeRouteUpdate(to, from ,next) &#123;</span><br><span class="line">    console.log(&quot;beforeRouteUpdate hook run.&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="29-Vue-组件中-data-为什么必须是函数"><a href="#29-Vue-组件中-data-为什么必须是函数" class="headerlink" title="29. Vue 组件中 data 为什么必须是函数"></a>29. Vue 组件中 data 为什么必须是函数</h2><p>因为组件是可以多次复用的，也就是说会有多个组件实例同时存在，同时由于对象是引用数据类型，如果所有组件实例都共用一个data数据对象，那么一个组件对data数据对象进行修改，那么其他组件实例也会受到影响，所以需要使用函数返回data对象的独立拷贝，使得每个组件实例都会拥有自己的data数据对象，相互之间独立，不会互相受影响，便于组件维护。</p>
<h2 id="30-vue-loader"><a href="#30-vue-loader" class="headerlink" title="30.vue-loader"></a>30.vue-loader</h2><p>vue-loader就是.vue组件的加载器，可以将.vue组件转换为javascript模块，及动态渲染一些数据，同时vue-loader还对.vue组件中的三个标签都进行了相应的优化。<code>&lt;template&gt;</code>标签中可以使用src属性引入一个组件，引入的组件可以直接使用当前组件中的数据，<code>&lt;script&gt;</code>标签中可以直接使用ES6语法，<code>&lt;style&gt;</code>标签可以默认使用sass并且支持scoped作用域选择。</p>
<h2 id="31-Vue中keep-alive的作用以及用法"><a href="#31-Vue中keep-alive的作用以及用法" class="headerlink" title="31.Vue中keep-alive的作用以及用法"></a>31.Vue中keep-alive的作用以及用法</h2><p><code>&lt;keep-alive&gt;</code>是vue中一个内置的组件，主要用于缓存组件，其会在组件created的时候，将需要缓存的组件放到缓存中，然后再render的时候再根据name进行取出。<code>&lt;keep-alive&gt;</code>主要配合路由进行使用，在配置路由的时候添加上meta元数据对象，里面添加上keepAlive属性，表示是否缓存该组件，然后将<code>&lt;router-view&gt;</code>放到<code>&lt;keep-alive&gt;</code>中，router-view通过v-if指令，从路由配置上的meta对象中取出keepAlive的值进行判断是否需要缓存</p>
<p>组件缓存后就不会执行组件的beforeCreate、created和beforeMount、mounted钩子了，所以其提供了actived和deactived钩子，actived钩子主要用于承担原来created钩子中获取数据的任务。</p>
<ul>
<li><p>mounted钩子 在主页挂载时执行一次，如果没有缓存的话，再次回到主页时，mounted还会执行，从而导致ajax反复获取数据。</p>
</li>
<li><p>activated钩子 则不受缓存的影响，每次重新回到主页都会执行。</p>
</li>
</ul>
<h2 id="32-vue-中的-data为什么是函数而不是属性值？"><a href="#32-vue-中的-data为什么是函数而不是属性值？" class="headerlink" title="32.vue 中的 data为什么是函数而不是属性值？"></a>32.vue 中的 data为什么是函数而不是属性值？</h2><p>当data定义为对象后，这就表示所有的组件实例共用了一份data数据，因此，无论在哪个组件实例中修改了data,都会影响到所有的组件实例。组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<h2 id="33-Vue-nextTick"><a href="#33-Vue-nextTick" class="headerlink" title="33.Vue.nextTick"></a>33.Vue.nextTick</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br><a href="https://www.cnblogs.com/hity-tt/p/6729118.html" target="_blank" rel="noopener">https://www.cnblogs.com/hity-tt/p/6729118.html</a></p>
<h2 id="34-vue-父子组件通信方式"><a href="#34-vue-父子组件通信方式" class="headerlink" title="34.vue 父子组件通信方式"></a>34.vue 父子组件通信方式</h2><ol>
<li>通过prop向子组件传递数据，子组件向父组件传递数值$emit</li>
<li>Vuex</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/Object.defineProperty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/Object.defineProperty/" itemprop="url">Object.defineProperty()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:38:19+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="两种定义形式的区别"><a href="#两种定义形式的区别" class="headerlink" title="两种定义形式的区别"></a>两种定义形式的区别</h2><h3 id="1-直接定义"><a href="#1-直接定义" class="headerlink" title="1.直接定义"></a>1.直接定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.name = &apos;jack&apos;</span><br><span class="line">//obj[&apos;name&apos;] = &apos;jack&apos;</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    value:&apos;jack&apos;,</span><br><span class="line">    writable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    enumberable:true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-Object-defineProperty-定义"><a href="#2-Object-defineProperty-定义" class="headerlink" title="2.Object.defineProperty()定义"></a>2.Object.defineProperty()定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    value:&apos;jack&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    value:&apos;jack&apos;,</span><br><span class="line">    writable:false,</span><br><span class="line">    configurable:false,</span><br><span class="line">    enumberable:false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Object-defineProperty-语法说明"><a href="#Object-defineProperty-语法说明" class="headerlink" title="Object.defineProperty()语法说明"></a>Object.defineProperty()语法说明</h2><p><code>Object.defineProperty(obj, prop, desc)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj : 需要定义属性的当前对象</span><br><span class="line">prop : 当前需要定义的属性名</span><br><span class="line">desc : 属性描述符</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>描述符</th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>存取描述符</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h3 id="描述符参数实例说明"><a href="#描述符参数实例说明" class="headerlink" title="描述符参数实例说明"></a>描述符参数实例说明</h3><h4 id="get-amp-set"><a href="#get-amp-set" class="headerlink" title="get &amp; set"></a>get &amp; set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get</span><br><span class="line">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。 默认为 undefined。</span><br><span class="line">set</span><br><span class="line">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 默认为 undefined。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let Person = &#123;&#125;</span><br><span class="line">let temp = null</span><br><span class="line">Object.defineProperty(Person, &apos;name&apos;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return temp</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (val) &#123;</span><br><span class="line">    temp = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span><br><span class="line"></span><br><span class="line">这个属性起到两个作用：</span><br><span class="line">(1)目标属性是否可以使用delete删除</span><br><span class="line">(2)目标属性是否可以再次设置特性</span><br></pre></td></tr></table></figure>

<h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</span><br></pre></td></tr></table></figure>

<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</span><br></pre></td></tr></table></figure>

<h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/React搭建工程脚手架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/React搭建工程脚手架/" itemprop="url">React搭建工程脚手架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:12:28+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><ul>
<li>安装node</li>
<li>安装git</li>
<li>VSCode</li>
</ul>
<h3 id="create-react-app基础脚手架"><a href="#create-react-app基础脚手架" class="headerlink" title="create-react-app基础脚手架"></a>create-react-app基础脚手架</h3><p>安装create-react-app</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure>

<p>安装完成后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-react-app react-plan </span><br><span class="line">cd react-test/</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>结束后，在浏览器访问<code>localhost:3000</code>,可以看到默认应用</p>
<p>###</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/npm install --save-dev和--save的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/npm install --save-dev和--save的区别/" itemprop="url">npm install 时--save-dev和--save的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:12:28+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在控制台敲指令时，经常碰到npm install –save-dev和–save</p>
<p>我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install moduleName # 安装模块到项目目录下</span><br><span class="line"> </span><br><span class="line">npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</span><br><span class="line"> </span><br><span class="line">npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。</span><br><span class="line"> </span><br><span class="line">npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。</span><br></pre></td></tr></table></figure>

<h2 id="npm-install-moduleName-命令"><a href="#npm-install-moduleName-命令" class="headerlink" title="npm install moduleName 命令"></a>npm install moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>
<li>运行 npm install 初始化项目时不会下载模块。</li>
</ol>
<h2 id="npm-install-g-moduleName-命令"><a href="#npm-install-g-moduleName-命令" class="headerlink" title="npm install -g moduleName 命令"></a>npm install -g moduleName 命令</h2><ol>
<li>安装模块到全局，不会在项目node_modules目录中保存模块包。</li>
<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>
<li>运行 npm install 初始化项目时不会下载模块。</li>
</ol>
<h2 id="npm-install-save-moduleName-命令"><a href="#npm-install-save-moduleName-命令" class="headerlink" title="npm install -save moduleName 命令"></a>npm install -save moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>会将模块依赖写入dependencies 节点。</li>
<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>
<li>运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</li>
</ol>
<h2 id="npm-install-save-dev-moduleName-命令"><a href="#npm-install-save-dev-moduleName-命令" class="headerlink" title="npm install -save-dev moduleName 命令"></a>npm install -save-dev moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>会将模块依赖写入devDependencies 节点。</li>
<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>
<li>运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dependencies是运行时依赖，devDependencies是开发时的依赖。</p>
<ul>
<li>devDependencies 下列出的模块，我们在发布后用不到它，而只是在我们开发才用到它。</li>
<li>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像react或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/基于Hexo的github博客搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuqi Qin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qyq.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuqi Qin's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/基于Hexo的github博客搭建/" itemprop="url">基于Hexo的github博客搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-06T17:12:28+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统环境配置"><a href="#系统环境配置" class="headerlink" title="系统环境配置"></a>系统环境配置</h2><p>系统：windows 10 </p>
<h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>下载地址 <a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a> </p>
<p>完成后命令行输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>

<h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>下载地址 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<p>完成后打开Git Bash</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure>

<h3 id="git-连接github配置"><a href="#git-连接github配置" class="headerlink" title="git 连接github配置"></a>git 连接github配置</h3><h4 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h4><h4 id="检查本机已存在的ssh密钥"><a href="#检查本机已存在的ssh密钥" class="headerlink" title="检查本机已存在的ssh密钥"></a>检查本机已存在的ssh密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh</span><br></pre></td></tr></table></figure>

<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<h4 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh key"></a>生成 ssh key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key。将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<h4 id="测试是否成功："><a href="#测试是否成功：" class="headerlink" title="测试是否成功："></a>测试是否成功：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com  # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>

<h4 id="如果提示Are-you-sure-you-want-to-continue-connecting-yes-no-，输入yes，然后会看到："><a href="#如果提示Are-you-sure-you-want-to-continue-connecting-yes-no-，输入yes，然后会看到：" class="headerlink" title="如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到："></a>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<h4 id="还需要配置："><a href="#还需要配置：" class="headerlink" title="还需要配置："></a>还需要配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;xxx&quot; #你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email &quot;xxx@gmail.com&quot; #填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<h2 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h2><h3 id="安装淘宝源的cnpm"><a href="#安装淘宝源的cnpm" class="headerlink" title="安装淘宝源的cnpm"></a>安装淘宝源的cnpm</h3><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>进入本地博客存放目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd f:</span><br><span class="line">$ cd hexo/blog/</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init #等待一段时间</span><br></pre></td></tr></table></figure>

<h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>执行完以后，你就可以去打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>  看本地版的博客效果了。</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>此处用next主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<h3 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h3><h4 id="修改Hexo目录下的-config-yml配置文件中的theme属性，将其设置为next"><a href="#修改Hexo目录下的-config-yml配置文件中的theme属性，将其设置为next" class="headerlink" title="修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next"></a>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next</h4><p>生成 静态页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml</span><br></pre></td></tr></table></figure>

<h4 id="本地-预览"><a href="#本地-预览" class="headerlink" title="本地 预览"></a>本地 预览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<h3 id="push到GitHub上"><a href="#push到GitHub上" class="headerlink" title="push到GitHub上"></a>push到GitHub上</h3><h4 id="修改站点目录的-config-yml-文件"><a href="#修改站点目录的-config-yml-文件" class="headerlink" title="修改站点目录的 _config.yml 文件"></a>修改站点目录的 _config.yml 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:abc/abcabc #这里填你自己的github地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>然后在命令行中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-deployer-git --save  //这是一个安装扩展，若已安装，可跳过</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/qyq.jpg" alt="Yuqi Qin">
            
              <p class="site-author-name" itemprop="name">Yuqi Qin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qyq1114" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:qyq1114@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/qyq1114" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/lady1114" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-globe"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuqi Qin</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
